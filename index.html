<!DOCTYPE html>
<html>
<head>
  <title>Face Landmarks Detection Example</title>
  <!-- Load TensorFlow.js and the face-landmarks-detection model -->
  <!-- Require the peer dependencies of face-landmarks-detection. -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>

<!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-detection"></script>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection"></script>


</head>
<body>
  <h1>Face Landmarks Detection Example</h1>
  <input type="file" id="inputImage" accept="image/*">
  <input type="file" id="inputImage2" accept="image/*">

  <button onclick="detectLandmarks()">Detect Landmarks</button>
  <button onclick="compareFaces()">Compare Faces</button>

  <div id="output" style="color:green;"></div>
  <div id="output2" style="color:red"></div>

  <script>
    async function detectLandmarks() {
      // Get the input image element
      const inputImage = document.getElementById('inputImage');
      const inputImage2 = document.getElementById('inputImage2');
      

      // Load the face landmarks detection model
      const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;
      const detectorConfig = {
        runtime: 'tfjs',
      };
      const detector = await faceLandmarksDetection.createDetector(model, detectorConfig);
      // Read the uploaded image file and convert to a tensor
      const file = inputImage.files[0];
      const file2 = inputImage2.files[0];

    //   IMAGE 1
      const reader = new FileReader();
      reader.onload = async () => {
        const image = new Image();
        image.onload = async () => {
          const tensor = tf.browser.fromPixels(image);
          // Detect landmarks on the input image
          const estimationConfig = {flipHorizontal: false};
          const faces = await detector.estimateFaces(tensor, estimationConfig);
          
          // Display the detected landmarks in the output div
          const outputDiv = document.getElementById('output');
          outputDiv.innerText = JSON.stringify(faces, null, 2);
        };
        image.src = reader.result;
      };
      reader.readAsDataURL(file);

    //   IMAGE 2 
    
      const reader2 = new FileReader();
      reader2.onload = async () => {
        const image = new Image();
        image.onload = async () => {
          const tensor = tf.browser.fromPixels(image);
          // Detect landmarks on the input image
          const estimationConfig = {flipHorizontal: false};
          const faces = await detector.estimateFaces(tensor, estimationConfig);
          // Display the detected landmarks in the output div
          const outputDiv2 = document.getElementById('output2');
          outputDiv2.innerText = JSON.stringify(faces, null, 2);
          
        };
        image.src = reader.result;
      };
      reader2.readAsDataURL(file2);



      const outputDiv1 = document.getElementById('output');
const facesJson1 = outputDiv1.innerText;
const faces1 = JSON.parse(facesJson1);

const outputDiv2 = document.getElementById('output2');
const facesJson2 = outputDiv2.innerText;
const faces2 = JSON.parse(facesJson2);

      const similarity = compareLandmarks(faces1[0].scaledMesh, faces2[0].scaledMesh);
        console.log(`Similarity: ${similarity}%`);
    }

    function compareLandmarks(landmarks1, landmarks2) {
  // Calculate the Euclidean distance between each corresponding point
  let distance = 0;
  for (let i = 0; i < landmarks1.length; i++) {
    const point1 = landmarks1[i];
    const point2 = landmarks2[i];
    const dx = point1.x - point2.x;
    const dy = point1.y - point2.y;
    distance += Math.sqrt(dx*dx + dy*dy);
  }

  // Normalize the distance to a percentage value (0-100)
  const maxDistance = landmarks1.length * Math.sqrt(2); // Maximum possible distance between two points
  const similarity = Math.max(0, (maxDistance - distance) / maxDistance) * 100;

  return similarity.toFixed(2);
}

</script>
</body>
</html>


 